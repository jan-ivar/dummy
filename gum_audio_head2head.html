<!DOCTYPE html>
<html>
<meta charset=utf-8>
<style id="compiled-css" type="text/css">
  body { white-space: nowrap; font-family: monospace; }
  table { border-collapse: collapse; }
  td { vertical-align: top; padding-right: 16px; }
  audio{background:#000;}
  .controls { margin-bottom: 8px; }
  .row { margin: 4px 0; }
  .row label { display: inline-block; width: 18ch; }
  .row.off label { opacity: .4; }
  input:disabled{ opacity: .4; }
  select:disabled{ opacity: .4; }
  .row label + select { margin-left: 6px; }
</style>
<table>
  <tr>
    <td>
      <div class="controls">
        <button id="openA">Microphone A</button> <select id="selA" style="display:none"></select>
        <div class="row"><input id="echoCancellationOnA" type="checkbox" checked> <label for="echoCancellationOnA">Echo cancellation</label> <select id="echoCancellationSelA"><option>True</option><option>False</option></select></div>
        <div class="row"><input id="noiseSuppressionOnA" type="checkbox" checked> <label for="noiseSuppressionOnA">Noise suppression</label> <select id="noiseSuppressionSelA"><option>True</option><option>False</option></select></div>
        <div class="row"><input id="autoGainControlOnA" type="checkbox" checked> <label for="autoGainControlOnA">Auto gain control</label> <select id="autoGainControlSelA"><option>True</option><option>False</option></select></div>
      </div>
    </td>
    <td>
      <div class="controls">
        <button id="openB">Microphone B</button> <select id="selB" style="display:none"></select>
        <div class="row"><input id="echoCancellationOnB" type="checkbox" checked> <label for="echoCancellationOnB">Echo cancellation</label> <select id="echoCancellationSelB"><option>True</option><option>False</option></select></div>
        <div class="row"><input id="noiseSuppressionOnB" type="checkbox" checked> <label for="noiseSuppressionOnB">Noise suppression</label> <select id="noiseSuppressionSelB"><option>True</option><option>False</option></select></div>
        <div class="row"><input id="autoGainControlOnB" type="checkbox" checked> <label for="autoGainControlOnB">Auto gain control</label> <select id="autoGainControlSelB"><option>True</option><option>False</option></select></div>
      </div>
    </td>
  </tr>
  <tr>
    <td id="ainfo">0x0</td>
    <td id="binfo">0x0</td>
  </tr>
  <tr>
    <td><audio id="vA" autoplay muted controls playsinline></audio></td>
    <td><audio id="vB" autoplay muted controls playsinline></audio></td>
  </tr>
  <tr>
    <td><canvas id="canvasA" style="display:none"></canvas></td>
    <td><canvas id="canvasB" style="display:none"></canvas></td>
  </tr>
</table>
<div id="div"></div>

<script>
const console = {log: msg => div.innerHTML += `${msg}<br>`};
const update = (el, msg) => el.innerHTML = msg;

function spectrum(stream, canvas) {
  const audioCtx = new AudioContext();
  const analyser = audioCtx.createAnalyser();
  audioCtx.createMediaStreamSource(stream).connect(analyser);
  if (!canvas.width) { canvas.width = canvas.clientWidth || 200; }
  canvas.height = 200;
  const ctx = canvas.getContext('2d');
  const data = new Uint8Array(canvas.width);
  ctx.strokeStyle = 'rgb(0, 125, 0)';
  const interval = setInterval(() => {
    ctx.fillStyle = '#a0a0a0';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    analyser.getByteFrequencyData(data);
    ctx.lineWidth = 2;
    let x = 0;
    for (let d of data) {
      const y = canvas.height - (d / 128) * canvas.height / 4;
      const c = Math.floor((x * 255) / canvas.width);
      ctx.fillStyle = `rgb(${c},0,${255 - x})`;
      ctx.fillRect(x++, y, 2, canvas.height - y);
    }
    analyser.getByteTimeDomainData(data);
    ctx.lineWidth = 5;
    ctx.beginPath();
    x = 0;
    for (let d of data) {
      const y = canvas.height - (d / 128) * canvas.height / 2;
      x ? ctx.lineTo(x++, y) : ctx.moveTo(x++, y);
    }
    ctx.stroke();
  }, 1000 * canvas.width / audioCtx.sampleRate);
  const cleanup = () => {
    audioCtx.close();
    clearInterval(interval);
  };
  const [track] = stream.getAudioTracks();
  track.addEventListener('ended', cleanup, {once: true});
  track.stop_ = track.stop;
  track.stop = () => track.stop_(cleanup());
  return stream;
}

function boolOf(s) {
  return String(s).toLowerCase() == 'true';
}

async function setAudio(v, vinfo, stream, canvas) {
  canvas.style.display = '';
  const w = v.clientWidth || v.offsetWidth || 300;
  canvas.width = w;
  stream = spectrum(stream, canvas);
  v.srcObject = stream;
  await new Promise(r => v.onloadedmetadata = r);
  if (v.interval) { clearInterval(v.interval); }
  const track = stream.getAudioTracks()[0];
  v.interval = setInterval(() => {
    const s = track.getSettings();
    const sr = s.sampleRate ? `${s.sampleRate}Hz` : '';
    const ch = s.channelCount ? `${s.channelCount}ch` : '';
    const ec = ('echoCancellation' in s) ? ` ec:${s.echoCancellation}` : '';
    const ns = ('noiseSuppression' in s) ? ` ns:${s.noiseSuppression}` : '';
    const agc = ('autoGainControl' in s) ? ` agc:${s.autoGainControl}` : '';
    const parts = [sr, ch].filter(x => x);
    update(vinfo, `${parts.join(' ')}${ec}${ns}${agc}` || '');
  }, 1000);
}

let audioDevices = [];
const cams = {
  A: {idx: 0, v: vA, info: ainfo, desired: {echoCancellation: true, noiseSuppression: true, autoGainControl: true}, enabled: {echoCancellation: true, noiseSuppression: true, autoGainControl: true}, deviceId: null, selection: null},
  B: {idx: 1, v: vB, info: binfo, desired: {echoCancellation: true, noiseSuppression: true, autoGainControl: true}, enabled: {echoCancellation: true, noiseSuppression: true, autoGainControl: true}, deviceId: null, selection: null}
};

function constraintFromDesired(desired, dev, enabled) {
  const c = {};
  if (enabled.echoCancellation) { c.echoCancellation = desired.echoCancellation; }
  if (enabled.noiseSuppression) { c.noiseSuppression = desired.noiseSuppression; }
  if (enabled.autoGainControl) { c.autoGainControl = desired.autoGainControl; }
  if (dev && dev.deviceId) { c.deviceId = {exact: dev.deviceId}; }
  return c;
}

function refreshSelectors(){
  if (!audioDevices.length) { return; }
  for (const [p, sel] of [['A', selA], ['B', selB]]) {
    sel.style.display = '';
    sel.innerHTML = '';
    let i = 0;
    for (const d of audioDevices) {
      i++;
      const o = document.createElement('option');
      o.value = d.deviceId;
      o.text = d.label || `Microphone ${i}`;
      sel.appendChild(o);
    }
    const o2 = document.createElement('option');
    o2.value = p=='A' ? 'clone:B' : 'clone:A';
    o2.text = p=='A' ? 'clone of Microphone B' : 'clone of Microphone A';
    sel.appendChild(o2);
    const other = (p=='A') ? 'B' : 'A';
    if (cams[p].selection) {
      sel.value = cams[p].selection;
    } else if (cams[p].deviceId) {
      sel.value = cams[p].deviceId;
    } else if (cams[other].deviceId) {
      const alt = audioDevices.find(d => d.deviceId != cams[other].deviceId);
      if (alt) { sel.value = alt.deviceId; }
    }
  }
}

selA.onchange = () => { cams.A.selection = selA.value || null; cams.A.deviceId = (cams.A.selection && cams.A.selection.indexOf('clone:') == 0) ? null : cams.A.selection; openMic('A'); };
selB.onchange = () => { cams.B.selection = selB.value || null; cams.B.deviceId = (cams.B.selection && cams.B.selection.indexOf('clone:') == 0) ? null : cams.B.selection; openMic('B'); };

function makeApply(prefix) {
  let applying = false, E, N, A;
  return async function apply(echoCancellation, noiseSuppression, autoGainControl) {
    E = Boolean(echoCancellation); N = Boolean(noiseSuppression); A = Boolean(autoGainControl);
    const cam = cams[prefix];
    if (!cam.track || applying) { return; }
    try {
      applying = true;
      do {
        echoCancellation = E; noiseSuppression = N; autoGainControl = A;
        const obj = {};
        if (cam.enabled.echoCancellation) { obj.echoCancellation = echoCancellation; }
        if (cam.enabled.noiseSuppression) { obj.noiseSuppression = noiseSuppression; }
        if (cam.enabled.autoGainControl) { obj.autoGainControl = autoGainControl; }
        await cam.track.applyConstraints(obj);
      } while (echoCancellation != E || noiseSuppression != N || autoGainControl != A);
    } catch (e) {
      console.log(e);
    } finally {
      applying = false;
    }
  }
}

cams.A.apply = makeApply('A');
cams.B.apply = makeApply('B');

function syncDesired(prefix) {
  for (const k of ['echoCancellation', 'noiseSuppression', 'autoGainControl']) {
    const sel = document.getElementById(k + 'Sel' + prefix);
    cams[prefix].desired[k] = boolOf(sel.value);
  }
}

function syncEnabled(prefix) {
  for (const k of ['echoCancellation', 'noiseSuppression', 'autoGainControl']) {
    const chk = document.getElementById(k + 'On' + prefix);
    cams[prefix].enabled[k] = chk.checked;
  }
}

async function openMic(prefix) {
  const cam = cams[prefix];
  const other = prefix == 'A' ? 'B' : 'A';
  syncEnabled(prefix);
  syncDesired(prefix);
  try {
    if (cam.stream) { cam.stream.getTracks().forEach(t => t.stop()); }
    const sel = cam.selection;
    if (sel && sel.indexOf('clone:') == 0) {
      const src = sel.slice(6);
      const srcCam = cams[src];
      if (!srcCam || !srcCam.stream) { console.log(`source ${src} not open`); return; }
      const stream = srcCam.stream.clone();
      cam.stream = stream;
      cam.track = stream.getAudioTracks()[0];
      const desired = constraintFromDesired(cam.desired, null, cam.enabled);
      await cam.track.applyConstraints(desired);
      await setAudio(cam.v, cam.info, stream, prefix == 'A' ? canvasA : canvasB);
      cam.apply(cams[prefix].desired.echoCancellation, cams[prefix].desired.noiseSuppression, cams[prefix].desired.autoGainControl);
      return;
    }
    let dev = null;
    if (cam.deviceId) {
      dev = {deviceId: cam.deviceId};
    } else if (audioDevices.length && cams[other].deviceId) {
      const rest = audioDevices.find(d => d.kind == 'audioinput' && d.deviceId != cams[other].deviceId);
      if (rest) { dev = {deviceId: rest.deviceId}; }
    }
    const constraints = {audio: constraintFromDesired(cam.desired, dev, cam.enabled)};
    const stream = await navigator.mediaDevices.getUserMedia(constraints);
    cam.stream = stream;
    cam.track = stream.getAudioTracks()[0];
    cam.deviceId = cam.track.getSettings().deviceId;
    if (!audioDevices.length){
      const devs = await navigator.mediaDevices.enumerateDevices();
      audioDevices = devs.filter(d => d.kind=='audioinput');
    }
    refreshSelectors();
    await setAudio(cam.v, cam.info, stream, prefix == 'A' ? canvasA : canvasB);
    cam.apply(cams[prefix].desired.echoCancellation, cams[prefix].desired.noiseSuppression, cams[prefix].desired.autoGainControl);
  } catch (e) {
    console.log(e);
  }
}

openA.onclick = () => openMic('A');
openB.onclick = () => openMic('B');

function bindBool(prefix, key) {
  const sel = document.getElementById(key + 'Sel' + prefix);
  const chk = document.getElementById(key + 'On' + prefix);
  const row = sel.parentElement;
  const set = val => {
    sel.value = val;
    cams[prefix].desired[key] = boolOf(val);
    if (cams[prefix].track) { cams[prefix].apply(cams[prefix].desired.echoCancellation, cams[prefix].desired.noiseSuppression, cams[prefix].desired.autoGainControl); }
  };
  sel.oninput = () => set(sel.value);
  chk.onchange = () => {
    cams[prefix].enabled[key] = chk.checked;
    sel.disabled = !chk.checked;
    if (cams[prefix].track) { cams[prefix].apply(cams[prefix].desired.echoCancellation, cams[prefix].desired.noiseSuppression, cams[prefix].desired.autoGainControl); }
    row.classList.toggle('off', !chk.checked);
  };
}

for (const p of ['A','B']) { bindBool(p, 'echoCancellation'); bindBool(p, 'noiseSuppression'); bindBool(p, 'autoGainControl'); }

for (const p of ['A','B']) {
  for (const k of ['echoCancellation','noiseSuppression','autoGainControl']) {
    const sel = document.getElementById(k + 'Sel' + p);
    const chk = document.getElementById(k + 'On' + p);
    const row = sel.parentElement;
    sel.disabled = !chk.checked;
    row.classList.toggle('off', !chk.checked);
    cams[p].enabled[k] = chk.checked;
  }
}
</script>
</html>
