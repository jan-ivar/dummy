<html>
<meta charset=utf-8>
<div id="div2"><br></div>
<button id="gum_audio">Start Mic!</button>
<button id="gum_video">Start Cam!</button>
<button id="gum_both">Start Both!</button>
<button id="stopp">Stop!</button><br>
<canvas id="canvas"></canvas><video id="video1" height="120" autoplay></video><br>
<div id="div"><br></div>
<script>
const console = {log: msg => div.innerHTML += `${msg}<br>`};
const update = msg => div2.innerHTML = `${msg}<br>`;
let unstopped = [];

async function gum({audio, video}) {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({audio, video});

    if (video1.srcObject && !audio != !video) {
      const [oldvideo] = video1.srcObject.getVideoTracks();
      const [oldaudio] = video1.srcObject.getAudioTracks();
      if (audio && oldvideo) {
        stream.addTrack(oldvideo);
      } else if (video && oldaudio) {
        stream.addTrack(oldaudio);
      }
    }
    video1.srcObject = spectrum(stream);
    unstopped.push(...video1.srcObject.getTracks());
  } catch (e) {
    console.log(e);
  } finally {
    enumerate();
  }
}

gum_audio.onclick = () => gum({audio: true});
gum_video.onclick = () => gum({video: true});
gum_both.onclick = () => gum({video: true, audio: true});

stopp.onclick = () => {
  unstopped.forEach(track => track.stop());
  unstopped = [];
  video1.srcObject = null;
  enumerate();
};

async function enumerate() {
  const devices = await navigator.mediaDevices.enumerateDevices();
  let s = "<ul>\n";
  const kinds = [
   {kind: "videoinput", heading: "Cameras"},
   {kind: "audioinput", heading: "Microphones"}
  ];
  for (const {kind, heading} of kinds) {
    const list = devices.filter(d => d.kind == kind);
    s += `<li>${heading}: ${list.length}</li>\n<ol>\n`;
    for (const {label, deviceId} of list) {
      const gumkind = (kind == "videoinput")? "video" : "audio";
      const chosen = video1?.srcObject?.getTracks().find(d => d.kind == gumkind)?.getSettings().deviceId == deviceId;
      s += `<li>"${label}" ${chosen? " (chosen)" : ""}</li>\n`;
    }
    s += "</ol>\n";
  }
  s += "</ul>\n";
  update(s);
}
enumerate();

navigator.mediaDevices.ondevicechange = () => {
  console.log("device change!");
  enumerate();
};

function spectrum(stream) {
  const audioCtx = new AudioContext();
  const analyser = audioCtx.createAnalyser();
  audioCtx.createMediaStreamSource(stream).connect(analyser);

  canvas.width = 80;
  canvas.height = 120;
  const ctx = canvas.getContext("2d");
  const data = new Uint8Array(canvas.width);
  ctx.strokeStyle = 'rgb(0, 125, 0)';

  const interval = setInterval(() => {
    ctx.fillStyle = "#a0a0a0";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    analyser.getByteFrequencyData(data);
    ctx.lineWidth = 2;
    let x = 0;
    for (let d of data) {
      const y = canvas.height - (d / 128) * canvas.height / 4;
      const c = Math.floor((x*255)/canvas.width);
      ctx.fillStyle = `rgb(${c},0,${255-x})`;
      ctx.fillRect(x++, y, 2, canvas.height - y)
    }

    analyser.getByteTimeDomainData(data);
    ctx.lineWidth = 5;
    ctx.beginPath();
    x = 0;
    for (let d of data) {
      const y = canvas.height - (d / 128) * canvas.height / 2;
      x ? ctx.lineTo(x++, y) : ctx.moveTo(x++, y);
    }
    ctx.stroke();
  }, 1000 * canvas.width / audioCtx.sampleRate);

  const cleanup = () => {
    audioCtx.close();
    clearInterval(interval);
  };
  const [track] = stream.getAudioTracks();
  track.addEventListener("ended", cleanup, {once: true});
  track.stop_ = track.stop;
  track.stop = () => track.stop_(cleanup());
  return stream;
}
</script>
</html>
